import lcm from 'lcm';
import _ from 'lodash';
import { ConversionError, ImpossibleSchemaError, InvalidSchemaError } from './convertOpenApi.js';
import { typeList, } from './types/endpoint.js';
export const convertSchema = (path, schema, required) => {
    if (schema === undefined) {
        throw new InvalidSchemaError(path, 'schema undefined');
    }
    // TODO(ronan): remove when fully migrated to endpoint type, or don't modify schema in evaluateCompositionsRecursive
    schema = _.cloneDeep(schema);
    schema = evaluateCompositionsRecursive(path, schema);
    return convertSchemaRecursive(path, schema, required);
};
/**
 * This function should be used to reduce strictly `oneOf` and `anyOf` compositions.
 *
 * @param schemaArray `schema.allOf` or `schema.oneOf`
 * @returns a schema array equivalent to the `schemaArray` argument, but in reduced form
 */
const evaluateOptionsCompositions = (path, schemaArray) => {
    const evaluatedArray = schemaArray.flatMap((subschema, i) => {
        var _a;
        try {
            return (_a = evaluateCompositionsRecursive([...path, i.toString()], subschema).oneOf) !== null && _a !== void 0 ? _a : [];
        }
        catch (error) {
            if (error instanceof ImpossibleSchemaError) {
                return [];
            }
            else {
                throw error;
            }
        }
    });
    if (evaluatedArray.length === 0) {
        throw new ImpossibleSchemaError(path, 'no valid options in schema:', JSON.stringify(schemaArray, undefined, 2));
    }
    return evaluatedArray;
};
const evaluateCompositionsRecursive = (path, schema) => {
    // evaluate compositions first; we are currently ignoring `not`
    if (schema.oneOf && schema.oneOf.length > 0) {
        schema.oneOf = evaluateOptionsCompositions([...path, 'oneOf'], schema.oneOf);
    }
    else {
        schema.oneOf = [];
    }
    if (schema.anyOf && schema.anyOf.length > 0) {
        schema.anyOf = evaluateOptionsCompositions([...path, 'anyOf'], schema.anyOf);
    }
    if (schema.allOf && schema.allOf.length > 0) {
        const totalAllOfObj = schema.allOf
            .map((subschema, i) => evaluateCompositionsRecursive([...path, 'allOf', i.toString()], subschema))
            .reduce((schema1, schema2, i) => combineReducedSchemas([...path, 'allOf', i.toString()], schema1, schema2), {
            oneOf: [],
        });
        schema.oneOf = multiplySchemaArrays(path, schema.oneOf, totalAllOfObj.oneOf);
    }
    // evaluate subschemas, if present
    if (schema.properties) {
        for (const key in schema.properties) {
            schema.properties[key] = evaluateCompositionsRecursive([...path, 'properties', key], schema.properties[key]);
        }
    }
    if (schema.items) {
        schema.items = evaluateCompositionsRecursive([...path, 'items'], schema.items);
    }
    if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
        try {
            schema.additionalProperties = evaluateCompositionsRecursive([...path, 'additionalProperties'], schema.additionalProperties);
        }
        catch (error) {
            if (error instanceof ImpossibleSchemaError) {
                // if additionalProperties schema is impossible, rather than error, just disallow additionalProperties
                schema.additionalProperties = false;
            }
            else {
                throw error;
            }
        }
    }
    if (schema.anyOf && schema.anyOf.length > 0) {
        schema.oneOf = multiplySchemaArrays(path, schema.oneOf, schema.anyOf);
    }
    const topLevelSchemaArray = generateTopLevelSchemaArray(schema);
    return { oneOf: multiplySchemaArrays(path, schema.oneOf, topLevelSchemaArray) };
};
const generateTopLevelSchemaArray = (schema) => {
    if (schema.nullable) {
        const typedSchema = Object.assign({}, schema);
        delete typedSchema.oneOf;
        delete typedSchema.nullable;
        const nullSchema = Object.assign({}, schema);
        delete nullSchema.oneOf;
        delete nullSchema.nullable;
        nullSchema.type = 'null';
        return [typedSchema, nullSchema];
    }
    if (Array.isArray(schema.type)) {
        if (schema.type.length === 0) {
            const topLevelSchema = Object.assign({}, schema);
            delete topLevelSchema.oneOf;
            delete topLevelSchema.type;
            return [topLevelSchema];
        }
        return schema.type.map((typeString) => {
            const topLevelSchema = Object.assign({}, schema);
            delete topLevelSchema.oneOf;
            topLevelSchema.type = typeString;
            return topLevelSchema;
        });
    }
    const topLevelSchema = Object.assign({}, schema);
    delete topLevelSchema.oneOf;
    return [topLevelSchema];
};
/**
 * Given two arrays representing schema options, return an array representing schema options that satisfy one element in both arrays.
 *
 * It is helpful to think of each array as a union of all the schemas in the array. This function can then be thought of as taking
 * the intersection of the two union types.
 *
 * @param a first array of schema options
 * @param b second array of schema options
 * @returns array of schemas that satisfy both arrays
 */
const multiplySchemaArrays = (path, a, b) => {
    if (a.length === 0 && b.length === 0) {
        return [{}];
    }
    if (a.length === 0) {
        return b;
    }
    if (b.length === 0) {
        return a;
    }
    const product = a.flatMap((schema1) => {
        return b.flatMap((schema2) => {
            try {
                const combinedSchema = combineTopLevelSchemas(path, schema1, schema2);
                return [combinedSchema];
            }
            catch (error) {
                if (error instanceof ImpossibleSchemaError) {
                    return [];
                }
                else {
                    throw error;
                }
            }
        });
    });
    if (product.length === 0) {
        throw new ImpossibleSchemaError(path, 'impossible schema combination:', 'schema array 1:', JSON.stringify(a, undefined, 2), 'schema array 2:', JSON.stringify(b, undefined, 2));
    }
    return product;
};
const combineReducedSchemas = (path, schema1, schema2) => {
    var _a, _b;
    return {
        oneOf: multiplySchemaArrays(path, ((_a = schema1.oneOf) !== null && _a !== void 0 ? _a : []), ((_b = schema2.oneOf) !== null && _b !== void 0 ? _b : [])),
    };
};
export const combineTopLevelSchemas = (path, schema1, schema2) => {
    var _a, _b;
    let type1 = schema1.type;
    let type2 = schema2.type;
    // don't throw an error if number type is being constricted
    if (type1 === 'integer' && type2 === 'number') {
        type2 = 'integer';
    }
    else if (type1 === 'number' && type2 === 'integer') {
        type1 = 'integer';
    }
    if (type1 && type2 && type1 !== type2) {
        throw new ImpossibleSchemaError(path, `mismatched type in composition: "${type1}" "${type2}"`);
    }
    for (const schema of [schema1, schema2]) {
        if (typeof schema.exclusiveMaximum === 'number') {
            if (schema.maximum === undefined || schema.maximum >= schema.exclusiveMaximum) {
                schema.maximum = schema.exclusiveMaximum;
                schema.exclusiveMaximum = true;
            }
            else {
                schema.exclusiveMaximum = undefined;
            }
        }
        if (typeof schema.exclusiveMinimum === 'number') {
            if (schema.minimum === undefined || schema.minimum <= schema.exclusiveMinimum) {
                schema.minimum = schema.exclusiveMinimum;
                schema.exclusiveMinimum = true;
            }
            else {
                schema.exclusiveMinimum = undefined;
            }
        }
    }
    const combinedSchema = {
        title: takeLast(schema1, schema2, 'title'),
        description: takeLast(schema1, schema2, 'description'),
        format: takeLast(schema1, schema2, 'format'),
        multipleOf: combine(schema1, schema2, 'multipleOf', lcm),
        maximum: combine(schema1, schema2, 'maximum', Math.min),
        minimum: combine(schema1, schema2, 'minimum', Math.max),
        maxLength: combine(schema1, schema2, 'maxLength', Math.min),
        minLength: combine(schema1, schema2, 'minLength', Math.max),
        maxItems: combine(schema1, schema2, 'maxItems', Math.min),
        minItems: combine(schema1, schema2, 'minItems', Math.max),
        maxProperties: combine(schema1, schema2, 'maxProperties', Math.min),
        minProperties: combine(schema1, schema2, 'minProperties', Math.max),
        required: combine(schema1, schema2, 'required', (a, b) => b.concat(a.filter((value) => !b.includes(value)))),
        enum: combine(schema1, schema2, 'enum', (a, b) => b.filter((value) => a.includes(value))),
        readOnly: schema1.readOnly && schema2.readOnly,
        writeOnly: schema1.writeOnly && schema2.writeOnly,
        deprecated: schema1.deprecated && schema2.deprecated,
    };
    combinedSchema.exclusiveMaximum =
        (schema1.maximum === combinedSchema.maximum ? schema1.exclusiveMaximum : undefined) ||
            (schema2.maximum === combinedSchema.maximum ? schema2.exclusiveMaximum : undefined);
    combinedSchema.exclusiveMinimum =
        (schema1.minimum === combinedSchema.minimum ? schema1.exclusiveMinimum : undefined) ||
            (schema2.minimum === combinedSchema.minimum ? schema2.exclusiveMinimum : undefined);
    if (typeof schema1.example === 'object' &&
        typeof schema2.example === 'object' &&
        (schema1.example != null || schema2.example != null)) {
        combinedSchema.example = Object.assign(Object.assign({}, schema1.example), schema2.example);
    }
    else {
        combinedSchema.example = takeLast(schema1, schema2, 'example');
    }
    const type = type1 !== null && type1 !== void 0 ? type1 : type2;
    if (type === 'array') {
        return Object.assign({ type, items: combineReducedSchemas([...path, 'items'], (_a = schema1.items) !== null && _a !== void 0 ? _a : {}, (_b = schema2.items) !== null && _b !== void 0 ? _b : {}) }, combinedSchema);
    }
    if (schema1.properties && schema2.properties) {
        const combinedProperties = Object.assign({}, schema1.properties);
        Object.entries(schema2.properties).forEach(([property, schema]) => {
            if (property in combinedProperties) {
                combinedProperties[property] = combineReducedSchemas([...path, 'properties', property], combinedProperties[property], schema);
            }
            else {
                combinedProperties[property] = schema;
            }
        });
        combinedSchema.properties = combinedProperties;
    }
    else if (schema1.properties || schema2.properties) {
        combinedSchema.properties = Object.assign(Object.assign({}, schema1.properties), schema2.properties);
    }
    if (schema1.additionalProperties === false || schema2.additionalProperties === false) {
        combinedSchema.additionalProperties = false;
    }
    else if (schema1.additionalProperties &&
        typeof schema1.additionalProperties === 'object' &&
        schema2.additionalProperties &&
        typeof schema2.additionalProperties === 'object') {
        combinedSchema.additionalProperties = combineReducedSchemas([...path, 'additionalProperties'], schema1.additionalProperties, schema2.additionalProperties);
    }
    else if (schema1.additionalProperties && typeof schema1.additionalProperties === 'object') {
        combinedSchema.additionalProperties = schema1.additionalProperties;
    }
    else if (schema2.additionalProperties && typeof schema2.additionalProperties === 'object') {
        combinedSchema.additionalProperties = schema2.additionalProperties;
    }
    return Object.assign({ type }, combinedSchema);
};
export const addKeyIfDefined = (key, value, destination) => {
    if (value !== undefined) {
        destination[key] = value;
    }
};
export const copyKeyIfDefined = (key, source, destination) => {
    if (source[key] !== undefined) {
        destination[key] = source[key];
    }
};
const takeLast = (schema1, schema2, key) => {
    var _a;
    return (_a = schema2[key]) !== null && _a !== void 0 ? _a : schema1[key];
};
const combine = (schema1, schema2, key, transform) => {
    var _a;
    return schema1[key] !== undefined && schema2[key] !== undefined
        ? transform(schema1[key], schema2[key])
        : (_a = schema1[key]) !== null && _a !== void 0 ? _a : schema2[key];
};
const convertSchemaRecursive = (path, schema, required) => {
    if (schema.oneOf === undefined || schema.oneOf.length === 0) {
        throw new ConversionError(path, 'missing schema definition');
    }
    const schemaArray = schema.oneOf.map((schema) => {
        const sharedProps = {};
        addKeyIfDefined('required', required, sharedProps);
        copyKeyIfDefined('title', schema, sharedProps);
        copyKeyIfDefined('description', schema, sharedProps);
        copyKeyIfDefined('readOnly', schema, sharedProps);
        copyKeyIfDefined('writeOnly', schema, sharedProps);
        copyKeyIfDefined('deprecated', schema, sharedProps);
        if (schema.type === undefined) {
            const inferredType = inferType(schema);
            if (inferredType === undefined) {
                return Object.assign({ type: 'any' }, sharedProps);
            }
            schema.type = inferredType;
        }
        const type = schema.type;
        if (!typeList.includes(type)) {
            throw new InvalidSchemaError(path, `invalid schema type: ${schema.type}`);
        }
        switch (schema.type) {
            case 'boolean':
                const booleanProps = sharedProps;
                copyKeyIfDefined('default', schema, booleanProps);
                copyKeyIfDefined('example', schema, booleanProps);
                return Object.assign({ type: schema.type }, booleanProps);
            case 'number':
            case 'integer':
                if (schema.enum) {
                    const numberEnumProps = sharedProps;
                    copyKeyIfDefined('default', schema, numberEnumProps);
                    copyKeyIfDefined('example', schema, numberEnumProps);
                    return Object.assign({ type: schema.type === 'number' ? 'numberEnum' : 'integerEnum', enum: schema.enum }, numberEnumProps);
                }
                const numberProps = sharedProps;
                copyKeyIfDefined('multipleOf', schema, numberProps);
                copyKeyIfDefined('maximum', schema, numberProps);
                copyKeyIfDefined('exclusiveMaximum', schema, numberProps);
                copyKeyIfDefined('minimum', schema, numberProps);
                copyKeyIfDefined('exclusiveMinimum', schema, numberProps);
                copyKeyIfDefined('default', schema, numberProps);
                copyKeyIfDefined('example', schema, numberProps);
                return Object.assign({ type: schema.type }, numberProps);
            case 'string':
                if (schema.enum) {
                    const stringEnumProps = sharedProps;
                    copyKeyIfDefined('default', schema, stringEnumProps);
                    copyKeyIfDefined('example', schema, stringEnumProps);
                    return Object.assign({ type: 'stringEnum', enum: schema.enum }, stringEnumProps);
                }
                const stringProps = sharedProps;
                copyKeyIfDefined('format', schema, stringProps);
                copyKeyIfDefined('pattern', schema, stringProps);
                copyKeyIfDefined('maxLength', schema, stringProps);
                copyKeyIfDefined('minLength', schema, stringProps);
                copyKeyIfDefined('default', schema, stringProps);
                copyKeyIfDefined('example', schema, stringProps);
                return Object.assign({ type: schema.type }, stringProps);
            case 'array':
                const arrayProps = sharedProps;
                copyKeyIfDefined('maxItems', schema, arrayProps);
                copyKeyIfDefined('minItems', schema, arrayProps);
                copyKeyIfDefined('uniqueItems', schema, arrayProps);
                copyKeyIfDefined('default', schema, arrayProps);
                copyKeyIfDefined('example', schema, arrayProps);
                return Object.assign({ type: schema.type, items: convertSchemaRecursive([...path, 'items'], schema.items) }, arrayProps);
            case 'object':
                const properties = convertProperties([...path, 'properties'], schema.properties, schema.required);
                const additionalProperties = typeof schema.additionalProperties === 'object' && schema.additionalProperties != null
                    ? convertSchemaRecursive([...path, 'additionalProperties'], schema.additionalProperties)
                    : schema.additionalProperties;
                const objectProperties = sharedProps;
                addKeyIfDefined('additionalProperties', additionalProperties, objectProperties);
                copyKeyIfDefined('maxProperties', schema, objectProperties);
                copyKeyIfDefined('minProperties', schema, objectProperties);
                copyKeyIfDefined('default', schema, objectProperties);
                copyKeyIfDefined('example', schema, objectProperties);
                return Object.assign({ type: schema.type, properties }, objectProperties);
            case 'null':
                const nullProps = sharedProps;
                copyKeyIfDefined('default', schema, nullProps);
                copyKeyIfDefined('example', schema, nullProps);
                return Object.assign({ type: schema.type }, nullProps);
            default:
                throw new ImpossibleSchemaError(path, `impossible type reached: ${schema.type}`);
        }
    });
    // must unpack first element to satisfy type
    return [schemaArray[0], ...schemaArray.slice(1)];
};
export const convertProperties = (path, properties, required) => {
    if (properties === undefined) {
        return {};
    }
    const newEntries = Object.entries(properties).map(([name, schema]) => {
        return [
            name,
            convertSchemaRecursive([...path, name], schema, (required === null || required === void 0 ? void 0 : required.includes(name)) ? true : undefined),
        ];
    });
    return Object.fromEntries(newEntries);
};
/**
 * Given an OpenAPI 3.1 schema, this function will attempt to determine the schema type
 * based on the properties present in the schema. This is useful for assigning types to
 * schemas that are missing a type.
 *
 * For example, if a schema has no type but has `schema.properties`, we can infer the
 * intended type is `object`.
 *
 * @param schema
 * @returns if exactly one type can be inferred, the string corresponding to that type; otherwise `undefined`
 */
const inferType = (schema) => {
    var _a, _b;
    let type = undefined;
    if (schema.format !== undefined ||
        schema.pattern !== undefined ||
        schema.minLength !== undefined ||
        schema.maxLength !== undefined ||
        ((_a = schema.enum) === null || _a === void 0 ? void 0 : _a.every((option) => typeof option === 'string'))) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'string';
    }
    if (schema.multipleOf !== undefined ||
        schema.minimum !== undefined ||
        schema.maximum !== undefined ||
        schema.exclusiveMinimum !== undefined ||
        schema.exclusiveMaximum !== undefined ||
        ((_b = schema.enum) === null || _b === void 0 ? void 0 : _b.every((option) => typeof option === 'number'))) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'number'; // less specific than 'integer'
    }
    if (schema.items !== undefined ||
        schema.minItems !== undefined ||
        schema.maxItems !== undefined ||
        schema.uniqueItems !== undefined) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'array';
    }
    if (schema.additionalProperties !== undefined ||
        schema.properties !== undefined ||
        schema.minProperties !== undefined ||
        schema.maxProperties !== undefined) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'object';
    }
    return type;
};
